<!DOCTYPE html>
<html>
<head>
    <title>Tile Capture Test</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            font-family: Arial, sans-serif; 
            background: #222; 
            color: white;
        }
        
        #gameContainer {
            display: flex;
            gap: 20px;
        }
        
        #gameBoard {
            flex: 1;
        }
        
        #controls {
            width: 300px;
            background: #333;
            padding: 20px;
            border-radius: 8px;
        }
        
        .test-tile {
            display: inline-block;
            width: 80px;
            height: 80px;
            margin: 5px;
            border: 2px solid #666;
            border-radius: 8px;
            cursor: pointer;
            background: #444;
            color: white;
            text-align: center;
            line-height: 76px;
            font-weight: bold;
            font-size: 16px;
        }
        
        .test-tile:hover {
            border-color: #ffff00;
            background: #555;
        }
        
        .test-tile.selected {
            border-color: #00ff00;
            background: #006600;
        }
        
        #debug {
            margin-top: 20px;
            padding: 10px;
            background: #111;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>Tile Capture Test Environment</h1>
    
    <div id="gameContainer">
        <div id="gameBoard"></div>
        <div id="controls">
            <h3>Test Scenario</h3>
            <p>Click a tile to select, then click on the board to place/capture.</p>
            
            <h4>Available Tiles:</h4>
            <div class="test-tile" data-tile="CITY">C<br>5</div>
            <div class="test-tile" data-tile="FIELD">F<br>3</div>
            <div class="test-tile" data-tile="ROAD">R<br>2</div>
            
            <h4>Current State:</h4>
            <div>Selected: <span id="selectedTile">None</span></div>
            <div>Current Player: <span id="currentPlayer">1</span></div>
            
            <button onclick="resetTest()" style="margin: 10px 0; padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset Test</button>
            <button onclick="switchPlayer()" style="margin: 10px 0; padding: 8px 16px; background: #006666; color: white; border: none; border-radius: 4px; cursor: pointer;">Switch Player</button>
            
            <div id="debug"></div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/dist/pixi.min.js"></script>
    <script>
        // Test constants
        const HEX_SIZE = 30;
        const HEX_WIDTH = HEX_SIZE * 2;
        const HEX_HEIGHT = Math.sqrt(3) * HEX_SIZE;
        const GRID_WIDTH = 7;
        const GRID_HEIGHT = 5;
        
        // Test state
        let app;
        let hexContainer;
        let hexGrid = [];
        let boardTiles = [];
        let selectedTile = null;
        let currentPlayer = 1;
        
        // Simple tile class for testing
        class TestTile {
            constructor(type, influence, char, color, owner = 'neutral') {
                this.type = type;
                this.baseInfluence = influence;
                this.char = char;
                this.color = color;
                this.owner = owner;
                this.col = null;
                this.row = null;
            }
            
            getRelativeInfluence() {
                if (this.col === null || this.row === null) {
                    return this.baseInfluence;
                }
                
                let totalInfluence = this.baseInfluence;
                const neighbors = getNeighbors(this.col, this.row);
                
                neighbors.forEach(neighborHex => {
                    if (!neighborHex.isEmpty && neighborHex.tile) {
                        if (neighborHex.tile.owner === this.owner) {
                            totalInfluence += neighborHex.tile.baseInfluence;
                        } else {
                            totalInfluence -= neighborHex.tile.baseInfluence;
                        }
                    }
                });
                
                return Math.max(0, totalInfluence);
            }
        }
        
        // Create hexagon graphics
        function createHexagon(color = 0x333333, strokeColor = 0x666666) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(color);
            graphics.lineStyle(2, strokeColor);
            graphics.moveTo(HEX_SIZE, 0);
            
            for (let i = 1; i <= 6; i++) {
                const angle = (i * Math.PI) / 3;
                graphics.lineTo(HEX_SIZE * Math.cos(angle), HEX_SIZE * Math.sin(angle));
            }
            
            graphics.endFill();
            return graphics;
        }
        
        // Create tile hex with text
        function createTileHex(tile) {
            const hex = createHexagon(tile.color, 0xffffff);
            
            const text = new PIXI.Text(`${tile.char}\\n${tile.getRelativeInfluence()}`, {
                fontFamily: 'Arial',
                fontSize: 14,
                fill: 0xffffff,
                fontWeight: 'bold',
                align: 'center'
            });
            text.anchor.set(0.5);
            hex.addChild(text);
            
            return hex;
        }
        
        // Grid coordinate conversion
        function gridToPixel(col, row) {
            const x = col * HEX_WIDTH * 0.75;
            const y = row * HEX_HEIGHT + (col % 2) * (HEX_HEIGHT / 2);
            return { x, y };
        }
        
        // Get neighbors
        function getNeighbors(col, row) {
            const neighbors = [];
            const offsets = col % 2 === 0 ? 
                [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]] :
                [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]];
            
            offsets.forEach(([dc, dr]) => {
                const newCol = col + dc;
                const newRow = row + dr;
                if (newCol >= 0 && newCol < GRID_WIDTH && newRow >= 0 && newRow < GRID_HEIGHT) {
                    neighbors.push(hexGrid[newCol][newRow]);
                }
            });
            
            return neighbors;
        }
        
        // Check if can place tile
        function canPlaceTile(col, row) {
            const hex = hexGrid[col][row];
            
            // Empty space - must be adjacent to friendly tile
            if (hex.isEmpty) {
                const neighbors = getNeighbors(col, row);
                const hasAdjacentFriendly = neighbors.some(neighbor => 
                    !neighbor.isEmpty && 
                    neighbor.tile && 
                    neighbor.tile.owner === `player${currentPlayer}`
                );
                log(`Empty space at ${col},${row}: hasAdjacentFriendly=${hasAdjacentFriendly}`);
                return hasAdjacentFriendly;
            }
            
            // Occupied space - can capture if 0 influence and not owned by current player
            if (!hex.isEmpty && hex.tile) {
                const influence = hex.tile.getRelativeInfluence();
                const canCapture = influence === 0 && hex.tile.owner !== `player${currentPlayer}`;
                log(`Occupied space at ${col},${row}: owner=${hex.tile.owner}, influence=${influence}, canCapture=${canCapture}`);
                return canCapture;
            }
            
            return false;
        }
        
        // Place tile
        function placeTile(col, row, tileType) {
            const hex = hexGrid[col][row];
            
            // Remove existing tile if capturing
            if (!hex.isEmpty && hex.tile) {
                const existingIndex = boardTiles.findIndex(bt => bt.col === col && bt.row === row);
                if (existingIndex !== -1) {
                    boardTiles.splice(existingIndex, 1);
                }
                log(`Captured ${hex.tile.type} at ${col},${row}`);
            }
            
            // Create new tile
            const colors = { CITY: 0x4444ff, FIELD: 0x44aa44, ROAD: 0x666666 };
            const influences = { CITY: 5, FIELD: 3, ROAD: 2 };
            const chars = { CITY: 'C', FIELD: 'F', ROAD: 'R' };
            
            const tile = new TestTile(
                tileType, 
                influences[tileType], 
                chars[tileType], 
                colors[tileType], 
                `player${currentPlayer}`
            );
            tile.col = col;
            tile.row = row;
            
            // Create visual
            const tileHex = createTileHex(tile);
            
            // Replace hex
            hexContainer.removeChild(hex);
            tileHex.x = hex.x;
            tileHex.y = hex.y;
            tileHex.gridCol = col;
            tileHex.gridRow = row;
            tileHex.isEmpty = false;
            tileHex.tile = tile;
            
            // Add click handler
            tileHex.interactive = true;
            tileHex.buttonMode = true;
            tileHex.on('pointerdown', () => handleHexClick(col, row));
            tileHex.on('pointerover', () => handleHexHover(col, row));
            tileHex.on('pointerout', () => handleHexOut());
            
            hexContainer.addChild(tileHex);
            hexGrid[col][row] = tileHex;
            
            // Update state
            boardTiles.push({ col, row, tile });
            updateAllTileDisplays();
            
            log(`Placed ${tileType} at ${col},${row} for player${currentPlayer}`);
        }
        
        // Update all tile displays
        function updateAllTileDisplays() {
            boardTiles.forEach(boardTile => {
                const hex = hexGrid[boardTile.col][boardTile.row];
                if (!hex.isEmpty && hex.tile) {
                    const oldText = hex.children.find(child => child instanceof PIXI.Text);
                    if (oldText) {
                        hex.removeChild(oldText);
                    }
                    
                    const newText = new PIXI.Text(`${hex.tile.char}\\n${hex.tile.getRelativeInfluence()}`, {
                        fontFamily: 'Arial',
                        fontSize: 14,
                        fill: 0xffffff,
                        fontWeight: 'bold',
                        align: 'center'
                    });
                    newText.anchor.set(0.5);
                    hex.addChild(newText);
                    
                    // Color code by influence
                    if (hex.tile.getRelativeInfluence() === 0 && hex.tile.owner !== `player${currentPlayer}`) {
                        hex.tint = 0xffaaaa; // Red for capturable
                    } else {
                        hex.tint = 0xffffff;
                    }
                }
            });
        }
        
        // Handle hex click
        function handleHexClick(col, row) {
            if (!selectedTile) {
                log('No tile selected');
                return;
            }
            
            if (canPlaceTile(col, row)) {
                placeTile(col, row, selectedTile);
                selectedTile = null;
                updateSelectedDisplay();
            } else {
                log(`Cannot place tile at ${col},${row}`);
            }
        }
        
        // Handle hex hover
        function handleHexHover(col, row) {
            const hex = hexGrid[col][row];
            if (selectedTile && canPlaceTile(col, row)) {
                hex.tint = 0x00ff00; // Green for valid
            } else if (selectedTile) {
                hex.tint = 0xff0000; // Red for invalid
            }
        }
        
        // Handle hex out
        function handleHexOut() {
            updateAllTileDisplays(); // Reset colors
        }
        
        // Initialize grid
        function initGrid() {
            hexContainer = new PIXI.Container();
            app.stage.addChild(hexContainer);
            
            // Center the grid
            hexContainer.x = 50;
            hexContainer.y = 50;
            
            for (let col = 0; col < GRID_WIDTH; col++) {
                hexGrid[col] = [];
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    const hex = createHexagon();
                    const pos = gridToPixel(col, row);
                    
                    hex.x = pos.x;
                    hex.y = pos.y;
                    hex.interactive = true;
                    hex.buttonMode = true;
                    hex.gridCol = col;
                    hex.gridRow = row;
                    hex.isEmpty = true;
                    hex.tile = null;
                    
                    hex.on('pointerdown', () => handleHexClick(col, row));
                    hex.on('pointerover', () => handleHexHover(col, row));
                    hex.on('pointerout', () => handleHexOut());
                    
                    hexContainer.addChild(hex);
                    hexGrid[col][row] = hex;
                }
            }
        }
        
        // Setup test scenario
        function setupTestScenario() {
            // Place player 1 capital
            placeTile(3, 1, 'CITY');
            
            // Place some neutral tiles
            const neutralTile1 = new TestTile('NEUTRAL', 1, 'N', 0x888888, 'neutral');
            neutralTile1.col = 3;
            neutralTile1.row = 2;
            
            const neutralHex = createTileHex(neutralTile1);
            const pos = gridToPixel(3, 2);
            neutralHex.x = pos.x;
            neutralHex.y = pos.y;
            neutralHex.gridCol = 3;
            neutralHex.gridRow = 2;
            neutralHex.isEmpty = false;
            neutralHex.tile = neutralTile1;
            neutralHex.interactive = true;
            neutralHex.buttonMode = true;
            neutralHex.on('pointerdown', () => handleHexClick(3, 2));
            neutralHex.on('pointerover', () => handleHexHover(3, 2));
            neutralHex.on('pointerout', () => handleHexOut());
            
            hexContainer.removeChild(hexGrid[3][2]);
            hexContainer.addChild(neutralHex);
            hexGrid[3][2] = neutralHex;
            boardTiles.push({ col: 3, row: 2, tile: neutralTile1 });
            
            updateAllTileDisplays();
            log('Test scenario setup complete');
        }
        
        // Logging
        function log(message) {
            const debugDiv = document.getElementById('debug');
            debugDiv.innerHTML += message + '<br>';
            debugDiv.scrollTop = debugDiv.scrollHeight;
            console.log(message);
        }
        
        // UI functions
        function updateSelectedDisplay() {
            document.getElementById('selectedTile').textContent = selectedTile || 'None';
        }
        
        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            document.getElementById('currentPlayer').textContent = currentPlayer;
            log(`Switched to player ${currentPlayer}`);
        }
        
        function resetTest() {
            // Clear everything
            hexContainer.removeChildren();
            hexGrid = [];
            boardTiles = [];
            selectedTile = null;
            currentPlayer = 1;
            
            document.getElementById('debug').innerHTML = '';
            document.getElementById('currentPlayer').textContent = '1';
            updateSelectedDisplay();
            
            // Reinitialize
            initGrid();
            setupTestScenario();
            log('Test environment reset');
        }
        
        // Initialize
        function init() {
            const gameBoard = document.getElementById('gameBoard');
            
            app = new PIXI.Application({
                width: 600,
                height: 400,
                backgroundColor: 0x1a1a1a,
                antialias: true
            });
            
            gameBoard.appendChild(app.view);
            
            initGrid();
            setupTestScenario();
            
            // Setup tile selection
            document.querySelectorAll('.test-tile').forEach(tile => {
                tile.addEventListener('click', () => {
                    document.querySelectorAll('.test-tile').forEach(t => t.classList.remove('selected'));
                    tile.classList.add('selected');
                    selectedTile = tile.dataset.tile;
                    updateSelectedDisplay();
                    log(`Selected ${selectedTile}`);
                });
            });
            
            log('Capture test environment initialized');
        }
        
        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
