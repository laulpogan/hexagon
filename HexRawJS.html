<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Stage.js Hex Grid â€” Axial, Tessellating, Adjacency</title>
  <style>
    html,body { margin:0; padding:0; background:#efefef; font-family:system-ui, Arial, sans-serif; }
    #hud {
      position:fixed; top:10px; left:10px; z-index:10;
      background:rgba(0,0,0,0.9); color:#fff; padding:10px 12px; border-radius:6px; font-size:12px;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div>Mouse: <span id="mouse">0,0</span></div>
    <div>Hover: <span id="hover">-</span></div>
    <div>Neighbors: <span id="nbrs">-</span></div>
  </div>

  <script src="dist/stage.web.js"></script>
  <script>
    // ===== Constants =====
    const R = 36;                       // hex radius (pointy-top)
    const SQRT3 = Math.sqrt(3);
    const COLS = 12;                    // axial q range: [0..COLS-1]
    const ROWS = 8;                     // axial r range: [0..ROWS-1]
    const ORIGIN = { x: 120, y: 120 };  // pixel offset for the grid

    // ===== Axial <-> Pixel (pointy-top) =====
    function axialToPixel(q, r) {
      const x = R * SQRT3 * (q + r/2) + ORIGIN.x;
      const y = R * 1.5 * r + ORIGIN.y;
      return { x, y };
    }
    function pixelToAxial(x, y) {
      const px = x - ORIGIN.x, py = y - ORIGIN.y;
      const qf = (SQRT3/3 * px - (1/3) * py) / R;
      const rf = ((2/3) * py) / R;
      return hexRound(qf, rf);
    }
    function hexRound(qf, rf) {
      let sf = -qf - rf;
      let q = Math.round(qf), r = Math.round(rf), s = Math.round(sf);
      const qd = Math.abs(q - qf), rd = Math.abs(r - rf), sd = Math.abs(s - sf);
      if (qd > rd && qd > sd) q = -r - s;
      else if (rd > sd)       r = -q - s;
      return { q, r };
    }

    // ===== Axial neighbors =====
    const DIRS = [
      { q:+1, r: 0 }, { q:-1, r: 0 },
      { q: 0, r:+1 }, { q: 0, r:-1 },
      { q:+1, r:-1 }, { q:-1, r:+1 },
    ];

    // ===== Grid model (axial) =====
    class Grid {
      constructor(cols, rows) {
        this.cols = cols;
        this.rows = rows;
        this.map = new Map();           // "q,r" -> {q,r,x,y,occ}
        this.build();
      }
      key(q,r){ return `${q},${r}`; }
      get(q,r){ return this.map.get(this.key(q,r)); }
      set(cell){ this.map.set(this.key(cell.q,cell.r), cell); }
      has(q,r){ return this.map.has(this.key(q,r)); }
      inBounds(q,r){ return q>=0 && q<this.cols && r>=0 && r<this.rows; }
      neighbors(q, r) {
        const out = [];
        for (const d of DIRS) {
          const nq = q + d.q, nr = r + d.r;
          if (this.inBounds(nq, nr)) {
            const c = this.get(nq, nr);
            if (c) out.push(c);
          }
        }
        return out;
      }
      build() {
        for (let r = 0; r < this.rows; r++) {
          for (let q = 0; q < this.cols; q++) {
            const p = axialToPixel(q, r);
            this.set({ q, r, x: p.x, y: p.y, occ: 0 });
          }
        }
      }
      each(fn){ this.map.forEach(fn); }
    }

    // ===== Stage setup (no auto fit/scaling, raw pixels) =====
    Stage(function(stage) {
      stage.viewport(1200, 800, 1);     // fixed pixel coordinates
      stage.background('#efefef');

      const layer = Stage.create().appendTo(stage).pin({ align: 0 });
      const grid = new Grid(COLS, ROWS);

      // draw one hex as a Stage.canvas image
      function hexCanvas(fill='#6b6b6b', stroke='#202020', alpha=1) {
        return Stage.canvas(function(ctx) {
          const size = R * 2 + 2;               // canvas box
          this.size(size, size);
          ctx.globalAlpha = alpha;

          const cx = size/2, cy = size/2;
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const a = Math.PI/3 * i;
            const px = cx + R * Math.cos(a);
            const py = cy + R * Math.sin(a);
            if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fillStyle = fill; ctx.fill();
          ctx.lineWidth = 1; ctx.strokeStyle = stroke; ctx.stroke();
        });
      }

      // sprites for normal / hover / neighbor highlight
      function tileSprite(kind='normal') {
        if (kind === 'hover')   return Stage.image(hexCanvas('#ffd200', '#111', 1)).pin({ align:0.5 });
        if (kind === 'nbr')     return Stage.image(hexCanvas('rgba(0,0,0,0)', '#19a974', 1)).pin({ align:0.5 });
        return Stage.image(hexCanvas('#6b6b6b', '#202020', 1)).pin({ align:0.5 });
      }

      // build visuals
      const visuals = new Map(); // "q,r" -> { base, hover, nbr }
      grid.each(cell => {
        const base  = tileSprite('normal').appendTo(layer).offset(cell.x, cell.y);
        const hover = tileSprite('hover').appendTo(layer).offset(cell.x, cell.y).hide();
        const nbr   = tileSprite('nbr').appendTo(layer).offset(cell.x, cell.y).hide();
        visuals.set(grid.key(cell.q, cell.r), { base, hover, nbr });
      });

      // HUD
      const hudMouse = document.getElementById('mouse');
      const hudHover = document.getElementById('hover');
      const hudNbrs  = document.getElementById('nbrs');

      // hover management
      let hoverKey = null;
      function showHover(q, r) {
        const key = grid.key(q,r);
        if (hoverKey === key) return;
        // clear old
        if (hoverKey) {
          const old = visuals.get(hoverKey);
          old && (old.hover.hide(), old.nbr.hide());
          const [oq, or] = hoverKey.split(',').map(Number);
          grid.neighbors(oq, or).forEach(c => visuals.get(grid.key(c.q, c.r)).nbr.hide());
        }
        // set new
        hoverKey = key;
        const v = visuals.get(key);
        if (!v) { hudHover.textContent = '-'; hudNbrs.textContent = '-'; return; }
        v.hover.show();
        const nbrs = grid.neighbors(q, r);
        nbrs.forEach(c => visuals.get(grid.key(c.q, c.r)).nbr.show());
        hudHover.textContent = `(${q},${r})`;
        hudNbrs.textContent = nbrs.map(n => `(${n.q},${n.r})`).join(' ');
      }

      // click handler (example: toggle occupancy color)
      function toggleOccupancy(q, r) {
        const cell = grid.get(q, r);
        if (!cell) return;
        cell.occ = cell.occ ? 0 : 1;
        const v = visuals.get(grid.key(q,r));
        const newImg = tileSprite(cell.occ ? 'hover' : 'normal');
        v.base.remove();
        v.base = newImg.appendTo(layer).offset(cell.x, cell.y); // keep visual state simple
        // re-apply hover overlay if this tile is hovered
        if (hoverKey === grid.key(q,r)) v.hover.show(); else v.hover.hide();
      }

      // pointer handling
      stage.on('mousemove', function(pt) {
        hudMouse.textContent = `${Math.round(pt.x)},${Math.round(pt.y)}`;
        const a = pixelToAxial(pt.x, pt.y);
        if (grid.inBounds(a.q, a.r)) showHover(a.q, a.r);
      });

      stage.on(Stage.Mouse.CLICK, function(pt) {
        const a = pixelToAxial(pt.x, pt.y);
        if (grid.inBounds(a.q, a.r)) toggleOccupancy(a.q, a.r);
      });

      // expose simple API for future game logic
      window.Hex = {
        grid,
        get(q,r){ return grid.get(q,r); },
        neighbors(q,r){ return grid.neighbors(q,r); },
        axialToPixel, pixelToAxial,
      };
    });
  </script>
</body>
</html>
