<!DOCTYPE html>
<html>
<head>
    <title>Hexagon Tile Placement Game - PixiJS</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif; 
            background: #1a1a1a; 
            overflow: hidden;
            color: white;
        }
        
        #gameContainer {
            display: flex;
            height: 100vh;
        }
        
        #gameBoard {
            flex: 1;
            position: relative;
        }
        
        #sidebar {
            width: 250px;
            background: #2a2a2a;
            padding: 20px;
            border-left: 2px solid #444;
        }
        
        #hand {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 10px;
            background: #222;
        }
        
        .hand-tile {
            width: 70px;
            height: 70px;
            margin: 4px;
            border: 2px solid #666;
            border-radius: 6px;
            display: inline-block;
            cursor: pointer;
            background: #333;
            color: white;
            text-align: center;
            line-height: 1.2;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.2s;
            vertical-align: top;
            padding: 4px;
            box-sizing: border-box;
        }
        
        .hand-tile:hover {
            border-color: #ffff00;
            background: #444;
            transform: scale(1.1);
        }
        
        .hand-tile.selected {
            border-color: #00ff00;
            background: #004400;
        }
        
        #score {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        #instructions {
            margin-top: 20px;
            font-size: 12px;
            color: #aaa;
            line-height: 1.4;
        }
        
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        /* Room Setup Styles */
        #roomSetup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        #roomSetup.hidden {
            display: none;
        }
        
        .room-container {
            background: #333;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .room-container h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        
        .room-container input {
            padding: 12px;
            margin: 10px;
            border: none;
            border-radius: 8px;
            background: #555;
            color: white;
            font-size: 16px;
            width: 250px;
        }
        
        .room-container button {
            padding: 12px 24px;
            margin: 10px;
            border: none;
            border-radius: 8px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        
        .room-container button:hover {
            background: #45a049;
        }
        
        .room-container button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status-connected { background: #4CAF50; }
        .status-waiting { background: #ff9800; }
        .status-error { background: #f44336; }
        
        /* Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 10001;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease-out;
        }
        
        .notification.success { background: #4CAF50; }
        .notification.info { background: #2196F3; }
        .notification.warning { background: #ff9800; }
        .notification.error { background: #f44336; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .multiplayer-info {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- Room Setup Modal -->
    <div id="roomSetup">
        <div class="room-container">
            <h2>ðŸŽ¯ Hex Tile Game</h2>
            <p>Create or join a multiplayer room!</p>
            <input type="text" id="roomCodeInput" placeholder="Room Code (e.g. DEMO123)" maxlength="8">
            <br>
            <button onclick="createRoom()">Create Room</button>
            <button onclick="joinRoom()">Join Room</button>
            <button onclick="playOffline()">Play Offline</button>
            <br>
            <div id="roomStatus"></div>
        </div>
    </div>

    <div id="debug">
        <div>Mouse: <span id="mouse">0, 0</span></div>
        <div>Selected: <span id="selected">None</span></div>
        <div>Hover: <span id="hover">-</span></div>
        <div>Room: <span id="roomInfo">-</span></div>
    </div>
    
    <div id="gameContainer">
        <div id="gameBoard"></div>
        <div id="sidebar">
            <h2>Hex Tile Game</h2>
            
            <div class="multiplayer-info">
                <div>Room: <span id="currentRoom">-</span></div>
                <div>You are: <span id="playerRole">Player 1</span></div>
                <div>Status: <span id="connectionStatus">Offline</span></div>
            </div>
            
            <div>Current Player: <span id="currentPlayerValue">1</span></div>
            <div>Phase: <span id="gamePhaseValue">Capital Placement</span></div>
            <div>Turn Phase: <span id="turnPhaseValue">Start</span></div>
            <div id="score">Score: <span id="scoreValue">0</span></div>
            <div>Turn: <span id="turnValue">1</span></div>
            
            <h3>Resources Available</h3>
            <div id="resources">
                <div>C: <span id="resourceC">0</span></div>
                <div>M: <span id="resourceM">0</span></div>
                <div>R: <span id="resourceR">0</span></div>
                <div>F: <span id="resourceF">0</span></div>
            </div>
            
            <button id="endTurnBtn" onclick="endPlayerTurn()" style="margin: 10px 0; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">End Turn</button>
            
            <button onclick="leaveRoom()" style="margin: 10px 0; padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Leave Room</button>
            
            <h3>Your Hand</h3>
            <div id="hand">
                <!-- Hand tiles will be generated here -->
            </div>
            
            <div id="instructions">
                <h4 id="instructionTitle">Capital Placement:</h4>
                <div id="instructionText">
                â€¢ Place your golden capital tile<br>
                â€¢ Must be within 3 ranks of no-man's-land<br>
                â€¢ Player 1: Above center, Player 2: Below center<br>
                â€¢ Capital provides all 4 resource types<br>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/dist/pixi.min.js"></script>
    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://hbklikgmdfekwroqbwtf.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhia2xpa2dtZGZla3dyb3Fid3RmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkzMzk0MjUsImV4cCI6MjA3NDkxNTQyNX0.Lmtba2Pp869mYX54q1gMCI2REUHKLoUBziSP73G6tog';
        
        // Multiplayer state
        let roomCode = '';
        let playerId = Math.random().toString(36).substr(2, 9);
        let playerNumber = null; // 1 or 2
        let gameRef = null;
        let isHost = false;
        let isMultiplayer = false;
        let gameChannel = null;
        let syncTimeout = null;
        
        // Initialize Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Test Supabase connection
        async function testSupabaseConnection() {
            try {
                const { data, error } = await supabase.from('rooms').select('count').limit(1);
                if (error) {
                    console.log('Supabase connection test:', error.message);
                    return false;
                }
                console.log('âœ… Supabase connected successfully!');
                return true;
            } catch (err) {
                console.log('âŒ Supabase connection failed:', err.message);
                return false;
            }
        }
        
        // Notification system
        function showNotification(message, type = 'info', duration = 3000) {
            // Remove existing notifications
            const existing = document.querySelectorAll('.notification');
            existing.forEach(n => n.remove());
            
            // Create new notification
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Auto-remove after duration
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideIn 0.3s ease-out reverse';
                    setTimeout(() => notification.remove(), 300);
                }
            }, duration);
        }
        
        // Game constants
        const HEX_SIZE = 40;
        const HEX_WIDTH = HEX_SIZE * 2;
        const HEX_HEIGHT = Math.sqrt(3) * HEX_SIZE;
        const GRID_WIDTH = 15;
        const GRID_HEIGHT = 10;
        
        // Tile class definition
        class Tile {
            constructor(type, baseInfluence, char, color, resourceTypes = [], cost = []) {
                this.type = type;
                this.baseInfluence = baseInfluence;
                this.char = char;
                this.color = color;
                this.resourceTypes = resourceTypes; // Array of resource types this tile provides (C, M, R, F)
                this.cost = cost; // Array of resource requirements to play this tile
                this.col = null;
                this.row = null;
                this.owner = 'player'; // For now, all tiles belong to player
                this.usedThisTurn = false; // Track if resources were used this turn
            }
            
            // Calculate relative influence based on adjacent tiles (friendly add, enemy subtract)
            getRelativeInfluence() {
                if (this.col === null || this.row === null) {
                    return this.baseInfluence; // Not placed yet, return base
                }
                
                let totalInfluence = this.baseInfluence;
                const neighbors = getNeighbors(this.col, this.row);
                
                neighbors.forEach(neighborHex => {
                    if (!neighborHex.isEmpty && neighborHex.tile) {
                        if (neighborHex.tile.owner === this.owner) {
                            // Friendly tiles add their base influence
                            totalInfluence += neighborHex.tile.baseInfluence;
                        } else {
                            // Enemy tiles (including neutral) subtract their base influence
                            totalInfluence -= neighborHex.tile.baseInfluence;
                        }
                    }
                });
                
                return Math.max(0, totalInfluence); // Never go below 0
            }
            
            // Get display text for this tile
            getDisplayText() {
                if (this.col === null || this.row === null) {
                    // In hand - show base influence and cost
                    const costStr = this.getCostString();
                    return `${this.char}\n${this.baseInfluence}${costStr ? '\n' + costStr : ''}`;
                } else {
                    // On board - show relative influence and resources
                    const resourceStr = this.getResourceString();
                    return `${this.char}\n${this.getRelativeInfluence()}${resourceStr ? '\n' + resourceStr : ''}`;
                }
            }
            
            // Get cost string for display
            getCostString() {
                if (this.cost.length === 0) return '';
                return `(${this.cost.join('')})`;
            }
            
            // Get resource string for display
            getResourceString() {
                if (this.resourceTypes.length === 0) return '';
                return `[${this.resourceTypes.join('')}]`;
            }
            
            // Check if this tile can provide a specific resource
            canProvideResource(resource) {
                return this.resourceTypes.includes(resource) && !this.usedThisTurn;
            }
        }
        
        // Tile deck definitions - balanced by cost vs influence
        const TILE_DECK = [
            // FREE TILES (0 cost) - Low influence
            { type: 'VILLAGE', influence: 1, char: 'V', resources: ['C'], cost: [], count: 8 },
            { type: 'CAMP', influence: 1, char: 'A', resources: ['R'], cost: [], count: 8 },
            { type: 'FARM', influence: 1, char: 'F', resources: ['F'], cost: [], count: 8 },
            { type: 'SHRINE', influence: 1, char: 'S', resources: ['M'], cost: [], count: 8 },
            
            // LOW COST TILES (1 resource) - Medium influence
            { type: 'TOWN', influence: 2, char: 'T', resources: ['C'], cost: ['C'], count: 6 },
            { type: 'ROAD', influence: 2, char: 'R', resources: ['R'], cost: ['R'], count: 6 },
            { type: 'FIELD', influence: 2, char: 'D', resources: ['F'], cost: ['F'], count: 6 },
            { type: 'TEMPLE', influence: 2, char: 'E', resources: ['M'], cost: ['M'], count: 6 },
            
            // MEDIUM COST TILES (2 resources) - High influence
            { type: 'CITY', influence: 3, char: 'C', resources: ['C', 'C'], cost: ['C', 'C'], count: 4 },
            { type: 'FORTRESS', influence: 3, char: 'X', resources: ['R', 'M'], cost: ['R', 'M'], count: 4 },
            { type: 'GRANARY', influence: 3, char: 'G', resources: ['F', 'C'], cost: ['F', 'C'], count: 4 },
            { type: 'CATHEDRAL', influence: 3, char: 'H', resources: ['M', 'C'], cost: ['M', 'C'], count: 4 },
            
            // HIGH COST TILES (3 resources) - Very high influence
            { type: 'CAPITAL', influence: 4, char: 'K', resources: ['C', 'M', 'R'], cost: ['C', 'M', 'R'], count: 2 },
            { type: 'STRONGHOLD', influence: 4, char: 'L', resources: ['R', 'M', 'F'], cost: ['R', 'M', 'F'], count: 2 },
            
            // LEGENDARY TILES (4 resources) - Extremely high influence
            { type: 'METROPOLIS', influence: 5, char: 'P', resources: ['C', 'M', 'R', 'F'], cost: ['C', 'M', 'R', 'F'], count: 1 }
        ];
        
        // Game state
        let playerDecks = { 1: [], 2: [] };
        let gameWon = false;
        let winner = null;
        
        // Game state
        let app;
        let hexContainer;
        let hexGrid = [];
        let boardTiles = [];
        let selectedTile = null;
        let playerHand = [];
        let score = 0;
        let currentTurn = 1;
        let currentPlayer = 1; // 1 or 2
        let gamePhase = 'capital_placement'; // 'capital_placement' or 'normal_play'
        let turnPhase = 'start_phase'; // 'start_phase', 'placement_phase', 'cleanup_phase'
        let playersReady = { 1: false, 2: false };
        let neutralTiles = [];
        
        // Initialize PixiJS
        function initPixi() {
            const gameBoard = document.getElementById('gameBoard');
            
            app = new PIXI.Application({
                width: gameBoard.offsetWidth,
                height: window.innerHeight,
                backgroundColor: 0x1a1a1a,
                antialias: true
            });
            
            gameBoard.appendChild(app.view);
            
            // Container for all hexagons
            hexContainer = new PIXI.Container();
            app.stage.addChild(hexContainer);
            
            // Center the grid
            hexContainer.x = app.screen.width / 2 - (GRID_WIDTH * HEX_WIDTH * 0.75) / 2;
            hexContainer.y = app.screen.height / 2 - (GRID_HEIGHT * HEX_HEIGHT) / 2;
        }
        
        // Create hexagon graphics
        function createHexagon(color = 0x333333, strokeColor = 0x666666, strokeWidth = 2) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(color);
            graphics.lineStyle(strokeWidth, strokeColor);
            graphics.moveTo(HEX_SIZE, 0);
            
            for (let i = 1; i <= 6; i++) {
                const angle = (i * Math.PI) / 3;
                graphics.lineTo(HEX_SIZE * Math.cos(angle), HEX_SIZE * Math.sin(angle));
            }
            
            graphics.endFill();
            return graphics;
        }
        
        // Get player-specific color for tiles
        function getPlayerColor(tile) {
            // Player-relative coloring
            if (tile.type === 'CAPITAL') {
                if (tile.owner === `player${playerNumber}`) {
                    return 0xffd700; // Gold for your capital
                } else {
                    return 0xff8800; // Orange for enemy capital
                }
            } else if (tile.owner === `player${playerNumber}`) {
                return 0x4488ff; // Blue for your tiles
            } else if (tile.owner && tile.owner.startsWith('player')) {
                return 0xff4444; // Red for enemy tiles
            } else if (tile.owner === 'neutral') {
                return 0x888888; // Gray for neutral
            } else {
                return 0x666666; // Dark gray for unowned
            }
        }
        
        // Create tile graphics with resource types and influence
        function createTileHex(tile, showRelativeInfluence = false) {
            const playerColor = getPlayerColor(tile);
            const hex = createHexagon(playerColor, 0xffffff, 3);
            
            // Show resource types as the main character(s), or special handling
            let resourceChar;
            if (tile.type === 'NEUTRAL') {
                resourceChar = 'N';
            } else if (tile.type === 'CAPITAL') {
                resourceChar = 'K';
            } else {
                resourceChar = tile.resourceTypes.length > 0 ? tile.resourceTypes.join('') : '?';
            }
            
            // Add resource character (white text)
            const charText = new PIXI.Text(resourceChar, {
                fontFamily: 'Arial',
                fontSize: 16,
                fill: 0xffffff,
                fontWeight: 'bold',
                align: 'center'
            });
            charText.anchor.set(0.5);
            charText.y = -12; // Position higher up
            hex.addChild(charText);
            
            // Add base influence (black text on white background)
            const baseInfluenceText = new PIXI.Text(tile.baseInfluence.toString(), {
                fontFamily: 'Arial',
                fontSize: 10,
                fill: 0x000000, // Black text
                fontWeight: 'bold',
                align: 'center'
            });
            baseInfluenceText.anchor.set(0.5);
            baseInfluenceText.y = 4; // Position below center
            
            // Add white background circle for base influence
            const baseBgCircle = new PIXI.Graphics();
            baseBgCircle.beginFill(0xffffff);
            baseBgCircle.drawCircle(0, 4, 7);
            baseBgCircle.endFill();
            hex.addChild(baseBgCircle);
            hex.addChild(baseInfluenceText);
            
            // If showing relative influence (on board), also show net influence
            if (showRelativeInfluence) {
                const relativeInfluence = tile.getRelativeInfluence();
                const relativeInfluenceText = new PIXI.Text(relativeInfluence.toString(), {
                    fontFamily: 'Arial',
                    fontSize: 12,
                    fill: 0xffffff, // White text
                    fontWeight: 'bold',
                    align: 'center'
                });
                relativeInfluenceText.anchor.set(0.5);
                relativeInfluenceText.y = 14; // Position lower
                hex.addChild(relativeInfluenceText);
            }
            
            return hex;
        }
        
        // Grid coordinate conversion
        function gridToPixel(col, row) {
            const x = col * HEX_WIDTH * 0.75;
            const y = row * HEX_HEIGHT + (col % 2) * (HEX_HEIGHT / 2);
            return { x, y };
        }
        
        // Initialize the hex grid
        function initHexGrid() {
            for (let col = 0; col < GRID_WIDTH; col++) {
                hexGrid[col] = [];
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    const hex = createHexagon();
                    const pos = gridToPixel(col, row);
                    
                    hex.x = pos.x;
                    hex.y = pos.y;
                    hex.interactive = true;
                    hex.buttonMode = true;
                    
                    hex.gridCol = col;
                    hex.gridRow = row;
                    hex.isEmpty = true;
                    hex.tile = null;
                    
                    // Hover effects
                    hex.on('pointerover', () => handleHexHover(col, row));
                    
                    hex.on('pointerout', () => {
                        hex.tint = 0xffffff; // Reset tint to show base color
                        document.getElementById('hover').textContent = '-';
                    });
                    
                    // Click to place tile
                    hex.on('pointerdown', () => handleHexClick(col, row));
                    
                    hexContainer.addChild(hex);
                    hexGrid[col][row] = hex;
                }
            }
        }
        
        // Check if a position is "in revolt" (0 influence and capturable)
        function isInRevolt(col, row) {
            const hex = hexGrid[col][row];
            if (hex.isEmpty) return false;
            if (!hex.tile) return false;
            
            const influence = hex.tile.getRelativeInfluence();
            const isEnemyOrNeutral = hex.tile.owner !== `player${currentPlayer}`;
            
            console.log(`Checking revolt at ${col},${row}: owner='${hex.tile.owner}', influence=${influence}, currentPlayer=player${currentPlayer}, isEnemyOrNeutral=${isEnemyOrNeutral}`);
            
            return influence === 0 && isEnemyOrNeutral;
        }
        
        // Check if a position is "secure" (has positive influence)
        function isSecure(col, row) {
            const hex = hexGrid[col][row];
            if (hex.isEmpty) return false;
            if (!hex.tile) return false;
            
            return hex.tile.getRelativeInfluence() > 0;
        }
        
        // Check if tile can be placed at position (unified logic for empty and revolt)
        function canPlaceTile(col, row) {
            const hex = hexGrid[col][row];
            
            // Case 1: Empty space - must be adjacent to friendly tile OR be first tile
            if (hex.isEmpty) {
                // If this is the first tile for this player, allow placement anywhere
                const playerTiles = boardTiles.filter(bt => bt.tile.owner === `player${currentPlayer}`);
                if (playerTiles.length === 0) {
                    return true; // First tile can be placed anywhere
                }
                
                // Otherwise, must be adjacent to friendly tile
                const neighbors = getNeighbors(col, row);
                const friendlyNeighbors = neighbors.filter(neighbor => 
                    !neighbor.isEmpty && 
                    neighbor.tile && 
                    neighbor.tile.owner === `player${currentPlayer}`
                );
                
                return friendlyNeighbors.length > 0;
            }
            
            // Case 2: Occupied space - can only place if in revolt
            if (!hex.isEmpty && hex.tile) {
                const influence = hex.tile.getRelativeInfluence();
                const isEnemyOrNeutral = hex.tile.owner !== `player${currentPlayer}`;
                const inRevolt = influence === 0 && isEnemyOrNeutral;
                
                return inRevolt;
            }
            
            return false;
        }
        
        // Get available resources from board tiles (only friendly tiles)
        function getAvailableResources() {
            const resources = { C: 0, M: 0, R: 0, F: 0 };
            
            boardTiles.forEach(boardTile => {
                if (boardTile.tile.owner === `player${currentPlayer}` && !boardTile.tile.usedThisTurn) {
                    boardTile.tile.resourceTypes.forEach(resource => {
                        resources[resource]++;
                    });
                }
            });
            
            return resources;
        }
        
        // Check if player can afford a tile
        function canAffordTile(tile) {
            // First tile placement is always free
            const playerTiles = boardTiles.filter(bt => bt.tile.owner === `player${playerNumber}`);
            if (playerTiles.length === 0) {
                return true;
            }
            
            if (tile.cost.length === 0) return true; // Free tiles
            
            const available = getAvailableResources();
            const required = {};
            
            // Count required resources
            tile.cost.forEach(resource => {
                required[resource] = (required[resource] || 0) + 1;
            });
            
            // Check if we have enough of each resource
            for (const [resource, amount] of Object.entries(required)) {
                if (available[resource] < amount) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Pay for a tile by marking resources as used (only friendly tiles)
        function payForTile(tile) {
            // First tile placement is always free
            const playerTiles = boardTiles.filter(bt => bt.tile.owner === `player${playerNumber}`);
            if (playerTiles.length === 0) {
                return;
            }
            
            if (tile.cost.length === 0) return; // Free tiles
            
            const costCopy = [...tile.cost];
            
            // Find friendly tiles to use for payment
            boardTiles.forEach(boardTile => {
                if (costCopy.length === 0) return;
                
                if (boardTile.tile.owner === `player${currentPlayer}` && !boardTile.tile.usedThisTurn) {
                    boardTile.tile.resourceTypes.forEach(resource => {
                        const costIndex = costCopy.indexOf(resource);
                        if (costIndex !== -1) {
                            costCopy.splice(costIndex, 1);
                            boardTile.tile.usedThisTurn = true;
                            
                            // Visual feedback - dim the tile
                            const hex = hexGrid[boardTile.col][boardTile.row];
                            hex.alpha = 0.6;
                        }
                    });
                }
            });
        }
        
        // Reset all tiles for new turn
        function startNewTurn() {
            currentTurn++;
            
            // Reset all friendly tiles' used status
            boardTiles.forEach(boardTile => {
                if (boardTile.tile.owner === `player${currentPlayer}`) {
                    boardTile.tile.usedThisTurn = false;
                    const hex = hexGrid[boardTile.col][boardTile.row];
                    hex.alpha = 1.0; // Restore full opacity
                }
            });
            
            // Update all tile displays (influence may have changed)
            updateAllTileDisplays();
            updateResourceDisplay();
        }
        
        // Update all tile displays on the board
        function updateAllTileDisplays() {
            boardTiles.forEach(boardTile => {
                const hex = hexGrid[boardTile.col][boardTile.row];
                if (!hex.isEmpty && hex.tile) {
                    // Remove old text and add updated text
                    const oldText = hex.children.find(child => child instanceof PIXI.Text);
                    if (oldText) {
                        hex.removeChild(oldText);
                    }
                    
                    let resourceChar;
                    if (hex.tile.type === 'NEUTRAL') {
                        resourceChar = 'N';
                    } else if (hex.tile.type === 'CAPITAL') {
                        resourceChar = 'K';
                    } else {
                        resourceChar = hex.tile.resourceTypes.length > 0 ? hex.tile.resourceTypes.join('') : '?';
                    }
                    
                    // Recreate the tile with updated influence
                    const updatedTileHex = createTileHex(hex.tile, true);
                    
                    // Copy position and properties
                    updatedTileHex.x = hex.x;
                    updatedTileHex.y = hex.y;
                    updatedTileHex.gridCol = hex.gridCol;
                    updatedTileHex.gridRow = hex.gridRow;
                    updatedTileHex.isEmpty = hex.isEmpty;
                    updatedTileHex.tile = hex.tile;
                    updatedTileHex.interactive = true;
                    updatedTileHex.buttonMode = true;
                    updatedTileHex.on('pointerdown', () => handleHexClick(hex.gridCol, hex.gridRow));
                    updatedTileHex.on('pointerover', () => handleHexHover(hex.gridCol, hex.gridRow));
                    updatedTileHex.on('pointerout', () => handleHexOut());
                    
                    // Replace in container and grid
                    hexContainer.removeChild(hex);
                    hexContainer.addChild(updatedTileHex);
                    hexGrid[hex.gridCol][hex.gridRow] = updatedTileHex;
                    
                    // Visual feedback for tile status
                    const influence = hex.tile.getRelativeInfluence();
                    const isEnemyOrNeutral = hex.tile.owner !== `player${currentPlayer}`;
                    
                    if (influence === 0 && isEnemyOrNeutral) {
                        hex.tint = 0x00ff00; // GREEN for capturable tiles!
                    } else if (influence === 0) {
                        hex.tint = 0xffaaaa; // Light red for friendly tiles at 0 (shouldn't happen)
                    } else {
                        hex.tint = 0xffffff; // Normal color for secure tiles
                    }
                }
            });
        }
        
        // Get neighboring hexes
        function getNeighbors(col, row) {
            const neighbors = [];
            const offsets = col % 2 === 0 ? 
                [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]] :
                [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]];
            
            offsets.forEach(([dc, dr]) => {
                const newCol = col + dc;
                const newRow = row + dr;
                if (newCol >= 0 && newCol < GRID_WIDTH && newRow >= 0 && newRow < GRID_HEIGHT) {
                    neighbors.push(hexGrid[newCol][newRow]);
                }
            });
            
            return neighbors;
        }
        
        // Place capital tile during setup phase
        function placeCapital(col, row, tile) {
            // Prevent placing multiple capitals
            if (playersReady[currentPlayer]) {
                console.log(`Player ${playerNumber}: Player ${currentPlayer} already placed their capital! playersReady:`, playersReady);
                showNotification(`Player ${currentPlayer} already placed their capital!`, 'warning');
                return;
            }
            
            tile.owner = `player${currentPlayer}`;
            placeTileDirectly(col, row, tile);
            
            // Mark player as ready
            playersReady[currentPlayer] = true;
            console.log(`Player ${playerNumber}: Marked player ${currentPlayer} as ready. playersReady:`, playersReady);
            
            // Clear selection but don't clear hand yet
            selectedTile = null;
            updateSelectedDisplay();
            
            // Sync to multiplayer if connected
            if (isMultiplayer) {
                syncGameState();
            }
            
            // Switch to next player or start normal game
            console.log(`Player ${playerNumber}: Checking if both players ready: playersReady[1]=${playersReady[1]}, playersReady[2]=${playersReady[2]}`);
            if (!playersReady[1] || !playersReady[2]) {
                // Switch to other player for capital placement
                const oldPlayer = currentPlayer;
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                console.log(`Player ${playerNumber}: Switched from Player ${oldPlayer} to Player ${currentPlayer}`);
                showNotification(`Player ${currentPlayer}'s turn to place capital!`, 'info');
                
                // Sync the turn change
                if (isMultiplayer) {
                    syncGameState();
                }
                
                // Give capital tile to the new current player
                if (currentPlayer === playerNumber) {
                    giveCapitalTile();
                }
                updateGamePhaseDisplay();
            } else {
                // Both capitals placed, transition to normal play
                console.log(`Player ${playerNumber}: Both capitals placed, transitioning to normal play`);
                
                // Sync the phase change immediately
                if (isMultiplayer) {
                    syncGameState();
                }
                
                // Transition to normal play (this will give this player their tiles)
                transitionToNormalPlay();
                
                console.log('Both capitals placed! Normal play begins.');
            }
        }
        
        // Place tile on board (handles both empty spaces and captures)
        function placeTile(col, row, tile) {
            const hex = hexGrid[col][row];
            
            console.log(`Placing ${tile.type} at ${col},${row} for player${currentPlayer}`);
            
            // Pay for the tile
            payForTile(tile);
            
            // If capturing an existing tile, remove it from boardTiles
            if (!hex.isEmpty && hex.tile) {
                const capturedTile = hex.tile;
                const existingTileIndex = boardTiles.findIndex(bt => bt.col === col && bt.row === row);
                if (existingTileIndex !== -1) {
                    boardTiles.splice(existingTileIndex, 1);
                }
                
                // Check for capital capture (win condition)
                if (capturedTile.type === 'CAPITAL') {
                    gameWon = true;
                    winner = currentPlayer;
                    console.log(`ðŸ† GAME WON! Player ${currentPlayer} captured the enemy capital!`);
                    alert(`ðŸ† VICTORY! Player ${currentPlayer} wins by capturing the enemy capital!`);
                    return; // Don't continue with placement
                }
                
                console.log(`Capturing tile at ${col},${row}! Was: ${capturedTile.type}, Now: ${tile.type}`);
            }
            
            // Set tile position and owner
            tile.col = col;
            tile.row = row;
            tile.owner = `player${currentPlayer}`;
            
            // Mark first tile as capital (check before adding to boardTiles)
            const playerTiles = boardTiles.filter(bt => bt.tile.owner === `player${currentPlayer}`);
            if (playerTiles.length === 0) {
                tile.type = 'CAPITAL';
                tile.char = 'K';
                tile.color = 0xFFFF00; // Yellow for capital
                console.log(`First tile becomes capital for player ${currentPlayer}`);
            }
            
            // Create visual representation
            const tileHex = createTileHex(tile, true); // Show relative influence on board
            
            // Add event handlers to new tile
            tileHex.interactive = true;
            tileHex.buttonMode = true;
            tileHex.on('pointerdown', () => handleHexClick(col, row));
            tileHex.on('pointerover', () => handleHexHover(col, row));
            tileHex.on('pointerout', () => handleHexOut());
            
            // Remove old hex and add tile
            hexContainer.removeChild(hex);
            tileHex.x = hex.x;
            tileHex.y = hex.y;
            tileHex.gridCol = col;
            tileHex.gridRow = row;
            tileHex.isEmpty = false;
            tileHex.tile = tile;
            
            hexContainer.addChild(tileHex);
            hexGrid[col][row] = tileHex;
            
            // Update game state
            boardTiles.push({ col, row, tile: tile });
            score += tile.baseInfluence; // Score based on base influence for now
            updateScore();
            
            // Remove tile from hand
            const handIndex = playerHand.indexOf(tile);
            if (handIndex > -1) {
                playerHand.splice(handIndex, 1);
                updateHand();
            }
            
            // Draw a new tile for the current player
            if (currentPlayer === playerNumber) {
                console.log(`Player ${playerNumber}: Drawing new tile after placement`);
                drawTurnTile();
            }
            
            // Update all tile displays (influence may have changed globally)
            updateAllTileDisplays();
            
            // Update resource display
            updateResourceDisplay();
            
            // Deselect
            selectedTile = null;
            updateSelectedDisplay();
            
            console.log(`Successfully placed ${tile.type} at ${col},${row}`);
            
            // Sync to multiplayer if connected
            if (isMultiplayer) {
                syncGameState();
            }
            
            // End turn automatically after placing one tile
            endPlayerTurn();
        }
        
        // Handle hex click (for placed tiles)
        function handleHexClick(col, row) {
            // Check if it's actually our turn
            if (currentPlayer !== playerNumber) {
                console.log(`Not your turn! Current player: ${currentPlayer}, You are: ${playerNumber}`);
                showNotification(`It's Player ${currentPlayer}'s turn!`, 'warning');
                return;
            }
            
            if (selectedTile) {
                // Handle first tile placement (becomes capital)
                if (boardTiles.length === 0) {
                    if (hexGrid[col][row].isEmpty) {
                        console.log(`Placing first tile (capital) at ${col},${row}`);
                        placeTile(col, row, selectedTile);
                    } else {
                        console.log(`Cannot place first tile: not empty space`);
                    }
                } else if (canPlaceTile(col, row) && canAffordTile(selectedTile)) {
                    console.log(`Attempting to place ${selectedTile.type} at ${col},${row}`);
                    placeTile(col, row, selectedTile);
                } else {
                    console.log(`Cannot place ${selectedTile.type} at ${col},${row}: canPlace=${canPlaceTile(col, row)}, canAfford=${canAffordTile(selectedTile)}`);
                }
            }
        }
        
        // Handle hex hover
        function handleHexHover(col, row) {
            const hex = hexGrid[col][row];
            if (selectedTile) {
                // Handle first tile hover (becomes capital)
                if (boardTiles.length === 0) {
                    if (hex.isEmpty) {
                        hex.tint = 0x00ff00; // Green for valid first tile placement
                        document.getElementById('hover').textContent = `${col},${row} (Place First Tile - FREE!)`;
                    } else {
                        hex.tint = 0xff0000; // Red for invalid first tile placement
                        document.getElementById('hover').textContent = `${col},${row} (Invalid - not empty space)`;
                    }
                } else {
                    // Normal play - check if can place and afford
                    const canPlace = canPlaceTile(col, row);
                    const canAfford = canAffordTile(selectedTile);
                    
                    if (canPlace && canAfford) {
                        if (isInRevolt(col, row)) {
                            hex.tint = 0xff8800; // Orange for revolt/capture
                            const tileType = hex.tile ? hex.tile.type : 'Unknown';
                            document.getElementById('hover').textContent = `${col},${row} (Capture ${tileType}!)`;
                        } else {
                            hex.tint = 0x00ff00; // Green for normal placement
                            // Check if this is first tile for this player
                            const playerTiles = boardTiles.filter(bt => bt.tile.owner === `player${currentPlayer}`);
                            if (playerTiles.length === 0) {
                                document.getElementById('hover').textContent = `${col},${row} (Place First Tile - FREE!)`;
                            } else {
                                document.getElementById('hover').textContent = `${col},${row} (Place)`;
                            }
                        }
                    } else {
                        hex.tint = 0xff0000; // Red for invalid
                        let reason = '';
                        if (!canPlace) reason += 'No adjacency/secure';
                        if (!canAfford) reason += (reason ? ', ' : '') + 'Cannot afford';
                        document.getElementById('hover').textContent = `${col},${row} (${reason})`;
                    }
                }
            } else {
                // No tile selected - show status based on current player
                if (hex.isEmpty) {
                    // Only highlight empty tiles if it's your turn
                    if (currentPlayer === playerNumber) {
                        hex.tint = 0x4444ff; // Blue tint for placeable empty tiles
                        document.getElementById('hover').textContent = `${col},${row} (Empty - Placeable)`;
                    } else {
                        hex.tint = 0x666666; // Gray for empty when not your turn
                        document.getElementById('hover').textContent = `${col},${row} (Empty)`;
                    }
                } else if (isInRevolt(col, row)) {
                    hex.tint = 0xffaaaa; // Light red for in revolt
                    document.getElementById('hover').textContent = `${col},${row} (In Revolt!)`;
                } else if (isSecure(col, row)) {
                    hex.tint = 0xaaffaa; // Light green for secure
                    document.getElementById('hover').textContent = `${col},${row} (Secure)`;
                } else {
                    hex.tint = 0xffffff; // Reset tint
                    document.getElementById('hover').textContent = `${col},${row}`;
                }
            }
        }
        
        // Handle hex out
        function handleHexOut() {
            updateAllTileDisplays(); // Reset colors
        }
        
        // Update displays of adjacent tiles when a new tile is placed
        function updateAdjacentTileDisplays(col, row) {
            const neighbors = getNeighbors(col, row);
            
            neighbors.forEach(neighborHex => {
                if (!neighborHex.isEmpty && neighborHex.tile) {
                    // Remove old text and add updated text
                    const oldText = neighborHex.children.find(child => child instanceof PIXI.Text);
                    if (oldText) {
                        neighborHex.removeChild(oldText);
                    }
                    
                    // Recreate the tile with updated influence
                    const updatedTileHex = createTileHex(neighborHex.tile, true);
                    
                    // Copy position and properties
                    updatedTileHex.x = neighborHex.x;
                    updatedTileHex.y = neighborHex.y;
                    updatedTileHex.gridCol = neighborHex.gridCol;
                    updatedTileHex.gridRow = neighborHex.gridRow;
                    updatedTileHex.isEmpty = neighborHex.isEmpty;
                    updatedTileHex.tile = neighborHex.tile;
                    updatedTileHex.interactive = true;
                    updatedTileHex.buttonMode = true;
                    updatedTileHex.on('pointerdown', () => handleHexClick(neighborHex.gridCol, neighborHex.gridRow));
                    updatedTileHex.on('pointerover', () => handleHexHover(neighborHex.gridCol, neighborHex.gridRow));
                    updatedTileHex.on('pointerout', () => handleHexOut());
                    
                    // Replace in container and grid
                    hexContainer.removeChild(neighborHex);
                    hexContainer.addChild(updatedTileHex);
                    hexGrid[neighborHex.gridCol][neighborHex.gridRow] = updatedTileHex;
                }
            });
        }
        
        // Create and shuffle a deck for a player
        function createPlayerDeck() {
            const deck = [];
            
            TILE_DECK.forEach(tileTemplate => {
                for (let i = 0; i < tileTemplate.count; i++) {
                    const tile = new Tile(
                        tileTemplate.type,
                        tileTemplate.influence,
                        tileTemplate.char,
                        0x000000, // Color will be set by getPlayerColor
                        [...tileTemplate.resources],
                        [...tileTemplate.cost]
                    );
                    deck.push(tile);
                }
            });
            
            // Shuffle the deck
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            
            console.log(`Created deck with ${deck.length} tiles`);
            return deck;
        }
        
        // Draw a tile from player's deck
        function drawTileFromDeck(player) {
            if (playerDecks[player].length === 0) {
                console.log(`Player ${player} deck is empty!`);
                return null;
            }
            
            const tile = playerDecks[player].pop();
            tile.owner = `player${player}`;
            console.log(`Player ${player} drew ${tile.type}`);
            return tile;
        }
        
        // Transition to normal play phase
        function transitionToNormalPlay() {
            console.log(`Player ${playerNumber}: Transitioning to normal play`);
            
            gamePhase = 'normal_play';
            currentPlayer = 1; // Player 1 goes first
            turnPhase = 'start_phase'; // Start with start phase
            
            // Give both players their starting hands (5 tiles + 1 capital)
            if (playerNumber === 1 || playerNumber === 2) {
                giveInitialHand();
            }
            
            // Start the first turn properly
            startNewTurn();
            
            showNotification('Game started! Place your first tile (it becomes your capital)!', 'success');
            updateGamePhaseDisplay();
            updateTurnPhaseDisplay();
        }
        
        // Start the game with initial hands
        function startGameWithInitialHands() {
            console.log(`Player ${playerNumber}: Starting game with initial hands`);
            console.log(`Player ${playerNumber}: Deck length: ${playerDecks[playerNumber] ? playerDecks[playerNumber].length : 'undefined'}`);
            
            transitionToNormalPlay();
        }

        // Give initial hand (5 normal tiles)
        function giveInitialHand() {
            console.log(`Player ${playerNumber}: Giving initial hand`);
            
            // Clear any existing hand
            playerHand = [];
            
            // Draw 5 regular tiles
            for (let i = 0; i < 5; i++) {
                const tile = drawTileFromDeck(playerNumber);
                if (tile) {
                    playerHand.push(tile);
                    console.log(`Player ${playerNumber} drew initial tile ${i+1}: ${tile.type}`);
                }
            }
            
            updateHand();
            console.log(`Player ${playerNumber} initial hand:`, playerHand.map(t => t.type));
        }

        // Draw a single tile for the current turn
        function drawTurnTile() {
            console.log(`drawTurnTile() called for Player ${playerNumber}, current hand length: ${playerHand.length}`);
            console.log(`Player ${playerNumber} deck length: ${playerDecks[playerNumber] ? playerDecks[playerNumber].length : 'undefined'}`);
            
            const tile = drawTileFromDeck(playerNumber);
            if (tile) {
                playerHand.push(tile);
                console.log(`Player ${playerNumber} drew turn tile: ${tile.type}`);
                updateHand();
            } else {
                console.log(`Player ${playerNumber} failed to draw turn tile - deck empty`);
                showNotification('Deck is empty!', 'warning');
            }
        }

        // Draw tiles for hand (used for initial setup)
        function drawTiles() {
            console.log(`drawTiles() called for Player ${playerNumber}, current hand length: ${playerHand.length}`);
            console.log(`Player ${playerNumber} deck length: ${playerDecks[playerNumber] ? playerDecks[playerNumber].length : 'undefined'}`);
            console.log(`Player ${playerNumber} deck contents:`, playerDecks[playerNumber] ? playerDecks[playerNumber].slice(0, 3).map(t => t.type) : 'undefined');
            
            playerHand = [];
            for (let i = 0; i < 5; i++) {
                const tile = drawTileFromDeck(playerNumber);
                if (tile) {
                    playerHand.push(tile);
                    console.log(`Player ${playerNumber} drew tile ${i+1}: ${tile.type}`);
                } else {
                    console.log(`Player ${playerNumber} failed to draw tile ${i+1} - deck empty or error`);
                }
            }
            updateHand();
            console.log(`Player ${playerNumber} drew ${playerHand.length} tiles for hand`);
            console.log(`Player ${playerNumber} final hand:`, playerHand.map(t => t.type));
        }
        
        // Update hand display
        function updateHand() {
            const handDiv = document.getElementById('hand');
            handDiv.innerHTML = '';
            
            // Add hand size indicator
            const sizeIndicator = document.createElement('div');
            sizeIndicator.style.cssText = 'color: #aaa; font-size: 12px; margin-bottom: 5px; text-align: center;';
            sizeIndicator.textContent = `${playerHand.length} tiles`;
            handDiv.appendChild(sizeIndicator);
            
            playerHand.forEach((tile, index) => {
                const tileDiv = document.createElement('div');
                tileDiv.className = 'hand-tile';
                
                // Create organized content within the tile
                const resourceChar = tile.resourceTypes.length > 0 ? tile.resourceTypes.join('') : '?';
                const influenceStr = `<div style="font-size:12px; color:#fff; margin-top:2px;">${tile.baseInfluence}</div>`;
                
                // Show cost, but mark as FREE if it's the first tile
                let costStr = '';
                const playerTiles = boardTiles.filter(bt => bt.tile.owner === `player${playerNumber}`);
                if (playerTiles.length === 0) {
                    costStr = `<div style="font-size:10px; color:#00ff00; margin-top:1px;">FREE</div>`;
                } else if (tile.cost.length > 0) {
                    costStr = `<div style="font-size:10px; color:#ffaa00; margin-top:1px;">(${tile.cost.join('')})</div>`;
                }
                
                tileDiv.innerHTML = `
                    <div style="font-size:18px; font-weight:bold;">${resourceChar}</div>
                    ${influenceStr}
                    ${costStr}
                `;
                
                // Dim if can't afford
                if (!canAffordTile(tile)) {
                    tileDiv.style.opacity = '0.5';
                    tileDiv.style.cursor = 'not-allowed';
                } else {
                    tileDiv.style.opacity = '1';
                    tileDiv.style.cursor = 'pointer';
                }
                
                tileDiv.onclick = () => {
                    if (canAffordTile(tile)) {
                        selectedTile = tile;
                        updateSelectedDisplay();
                        
                        // Update visual selection
                        document.querySelectorAll('.hand-tile').forEach(t => t.classList.remove('selected'));
                        tileDiv.classList.add('selected');
                    }
                };
                
                handDiv.appendChild(tileDiv);
            });
        }
        
        // Update selected tile display
        function updateSelectedDisplay() {
            if (selectedTile) {
                const resourceChar = selectedTile.resourceTypes.length > 0 ? selectedTile.resourceTypes.join('') : '?';
                const display = `${resourceChar} (${selectedTile.baseInfluence})`;
                document.getElementById('selected').textContent = display;
                
                // Highlight all valid placement positions
                highlightValidPlacements();
            } else {
                document.getElementById('selected').textContent = 'None';
                
                // Reset all highlighting
                updateAllTileDisplays();
            }
        }
        
        // Highlight all valid placement positions
        function highlightValidPlacements() {
            for (let col = 0; col < GRID_WIDTH; col++) {
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    const hex = hexGrid[col][row];
                    if (canPlaceTile(col, row) && canAffordTile(selectedTile)) {
                        if (hex.isEmpty) {
                            hex.tint = 0x88ff88; // Light green for empty valid spaces
                        } else {
                            hex.tint = 0x00ff00; // Bright green for capturable tiles
                        }
                    }
                }
            }
        }
        
        // Update score display
        function updateScore() {
            document.getElementById('scoreValue').textContent = score;
        }
        
        // Update resource display
        function updateResourceDisplay() {
            const resources = getAvailableResources();
            document.getElementById('resourceC').textContent = resources.C;
            document.getElementById('resourceM').textContent = resources.M;
            document.getElementById('resourceR').textContent = resources.R;
            document.getElementById('resourceF').textContent = resources.F;
            document.getElementById('turnValue').textContent = currentTurn;
            document.getElementById('currentPlayerValue').textContent = currentPlayer;
        }
        
        // Update game phase display
        function updateGamePhaseDisplay() {
            document.getElementById('gamePhaseValue').textContent = 'Normal Play';
            document.getElementById('instructionTitle').textContent = 'Normal Play:';
            document.getElementById('instructionText').innerHTML = 
                'â€¢ Click tiles in your hand to select them<br>' +
                'â€¢ Place your first tile anywhere (it becomes your capital)<br>' +
                'â€¢ Then place other tiles adjacent to existing ones<br>' +
                'â€¢ Pay costs using tile resources<br>' +
                'â€¢ (Cost) = required resources<br>';
        }
        
        // Update turn phase display
        function updateTurnPhaseDisplay() {
            const phaseNames = {
                'start_phase': 'Start (Card Draw)',
                'placement_phase': 'Placement',
                'cleanup_phase': 'Cleanup'
            };
            
            document.getElementById('turnPhaseValue').textContent = phaseNames[turnPhase] || turnPhase;
        }
        
        // End player turn
        function endPlayerTurn() {
            if (gamePhase === 'normal_play') {
                // Move to cleanup phase first
                turnPhase = 'cleanup_phase';
                updateTurnPhaseDisplay();
                
                // After cleanup, switch players and start new turn
                setTimeout(() => {
                    const oldPlayer = currentPlayer;
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    
                    console.log(`Turn switching: ${oldPlayer} â†’ ${currentPlayer}`);
                    showNotification(`Player ${currentPlayer}'s turn!`, 'info');
                    
                    // Start new turn with start phase
                    startNewTurn();
                    
                    updateGamePhaseDisplay();
                    updateTurnPhaseDisplay();
                    
                    // Sync to multiplayer if connected
                    if (isMultiplayer) {
                        syncGameState();
                    }
                }, 500); // Small delay for visual feedback
            }
        }
        
        function startNewTurn() {
            if (gamePhase === 'normal_play') {
                turnPhase = 'start_phase';
                updateTurnPhaseDisplay();
                
                console.log(`Starting new turn for Player ${currentPlayer} - Start Phase`);
                
                // Always draw a card at the start of each turn
                if (currentPlayer === playerNumber) {
                    console.log(`Player ${playerNumber}: Drawing card for start phase`);
                    drawTurnTile();
                }
                
                // Move to placement phase after card draw
                setTimeout(() => {
                    turnPhase = 'placement_phase';
                    updateTurnPhaseDisplay();
                    console.log(`Player ${currentPlayer} - Placement Phase`);
                }, 1000);
            }
        }
        
        // Mouse tracking
        function initMouseTracking() {
            app.stage.interactive = true;
            app.stage.on('pointermove', (event) => {
                const pos = event.data.global;
                document.getElementById('mouse').textContent = `${Math.round(pos.x)}, ${Math.round(pos.y)}`;
            });
        }
        
        // No longer using neutral no-man's-land
        
        // Place tile directly without game logic checks (for setup)
        function placeTileDirectly(col, row, tile) {
            const hex = hexGrid[col][row];
            
            // Set tile position
            tile.col = col;
            tile.row = row;
            
            // Create visual representation
            const tileHex = createTileHex(tile, true);
            
            // Remove old hex and add tile
            hexContainer.removeChild(hex);
            tileHex.x = hex.x;
            tileHex.y = hex.y;
            tileHex.gridCol = col;
            tileHex.gridRow = row;
            tileHex.isEmpty = false;
            tileHex.tile = tile;
            
            hexContainer.addChild(tileHex);
            hexGrid[col][row] = tileHex;
            
            // Update game state
            boardTiles.push({ col, row, tile: tile });
        }
        
        // Check if position is valid for capital placement
        function isValidCapitalPlacement(col, row, player) {
            if (gamePhase !== 'capital_placement') return false;
            if (playersReady[player]) return false; // Player already placed capital
            
            // Capitals can be placed anywhere on empty spaces
            const hex = hexGrid[col][row];
            return hex.isEmpty;
        }
        
        // Give player their capital tile (special starting tile)
        function giveCapitalTile() {
            if (gamePhase === 'capital_placement') {
                const capitalTile = new Tile(
                    'CAPITAL', 
                    1, // Reduced capital influence to 1
                    'K', 
                    0xffd700, 
                    ['C', 'M', 'R', 'F'], // Provides all resources
                    [] // Free to place
                );
                capitalTile.owner = `player${currentPlayer}`;
                playerHand = [capitalTile];
                updateHand();
            }
        }
        
        // Initialize game
        function initGame() {
            initPixi();
            initHexGrid();
            initMouseTracking();
            
            // Create shuffled decks for both players
            playerDecks[1] = createPlayerDeck();
            playerDecks[2] = createPlayerDeck();
            
            // Start game with initial hands (5 tiles + 1 capital each)
            startGameWithInitialHands();
            
            updateScore();
            updateResourceDisplay();
            
            console.log('PixiJS Hex Tile Game initialized! Place your capital tile from your hand.');
            console.log(`Player decks created: P1=${playerDecks[1].length} tiles, P2=${playerDecks[2].length} tiles`);
        }
        
        // Multiplayer functions
        function createRoom() {
            roomCode = document.getElementById('roomCodeInput').value.toUpperCase() || 'DEMO' + Math.floor(Math.random() * 1000);
            playerNumber = 1;
            isHost = true;
            isMultiplayer = true;
            
            document.getElementById('roomStatus').innerHTML = 
                `<div class="status-message status-waiting">Room ${roomCode} created! Share this code with your opponent.</div>`;
            
            // Set up Supabase room
            setupSupabaseRoom();
        }
        
        function joinRoom() {
            roomCode = document.getElementById('roomCodeInput').value.toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code!');
                return;
            }
            
            playerNumber = 2;
            isHost = false;
            isMultiplayer = true;
            
            document.getElementById('roomStatus').innerHTML = 
                `<div class="status-message status-waiting">Joining room ${roomCode}...</div>`;
            
            // Set up Supabase room
            setupSupabaseRoom();
        }
        
        function playOffline() {
            isMultiplayer = false;
            hideRoomSetup();
            startGame();
        }
        
        function leaveRoom() {
            if (isMultiplayer && roomCode) {
                // Clean up Supabase connection
                if (gameChannel) {
                    gameChannel.unsubscribe();
                }
            }
            
            // Reset game state
            location.reload();
        }
        
        function hideRoomSetup() {
            document.getElementById('roomSetup').classList.add('hidden');
            document.getElementById('currentRoom').textContent = roomCode || 'Offline';
            document.getElementById('playerRole').textContent = `Player ${playerNumber}`;
            document.getElementById('connectionStatus').textContent = isMultiplayer ? 'Connected' : 'Offline';
            document.getElementById('roomInfo').textContent = roomCode || 'Offline';
        }
        
        async function setupSupabaseRoom() {
            try {
                if (isHost) {
                    // Create a new room
                    const { data: roomData, error: roomError } = await supabase
                        .from('rooms')
                        .insert([{
                            room_code: roomCode,
                            game_state: {
                                currentPlayer: 1,
                                gamePhase: 'normal_play',
                                boardTiles: [],
                                playersReady: { 1: true, 2: true }
                            },
                            player1_id: playerId
                        }])
                        .select()
                        .single();
                    
                    if (roomError) {
                        console.error('Room creation error:', roomError);
                        throw new Error(`Failed to create room: ${roomError.message}`);
                    }
                    
                    gameRef = roomData.id;
                    console.log('Room created successfully:', roomData);
                    showNotification(`Room ${roomCode} created! Waiting for Player 2...`, 'success');
                    
                    // Small delay to ensure room is fully created
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    // Join existing room
                    console.log('Looking for room with code:', roomCode);
                    
                    const { data: roomData, error: roomError } = await supabase
                        .from('rooms')
                        .select('*')
                        .eq('room_code', roomCode)
                        .eq('is_active', true)
                        .single();
                    
                    if (roomError) {
                        console.error('Room query error:', roomError);
                        throw new Error(`Room not found: ${roomError.message}`);
                    }
                    
                    if (!roomData) {
                        throw new Error('Room not found or not active');
                    }
                    
                    console.log('Found room:', roomData);
                    gameRef = roomData.id;
                    
                    // Check if room already has 2 players
                    if (roomData.player2_id) {
                        throw new Error('Room is full');
                    }
                    
                    // Add player to room
                    const { error: playerError } = await supabase
                        .from('players')
                        .insert([{
                            id: playerId,
                            room_id: gameRef,
                            player_number: 2
                        }]);
                    
                    if (playerError) {
                        console.error('Player insert error:', playerError);
                        throw new Error(`Failed to join room: ${playerError.message}`);
                    }
                    
                    // Update room with player 2
                    const { error: updateError } = await supabase
                        .from('rooms')
                        .update({ player2_id: playerId })
                        .eq('id', gameRef);
                    
                    if (updateError) {
                        console.error('Room update error:', updateError);
                        throw new Error(`Failed to update room: ${updateError.message}`);
                    }
                    
                    console.log('Successfully joined room:', roomData);
                    showNotification(`Joined room ${roomCode} as Player 2!`, 'success');
                }
                
                // Set up real-time subscription
                setupRealtimeSubscription();
                
                hideRoomSetup();
                startGame();
                
                document.getElementById('roomStatus').innerHTML = 
                    `<div class="status-message status-connected">Connected to room ${roomCode}!</div>`;
                    
            } catch (error) {
                console.error('Error setting up room:', error);
                document.getElementById('roomStatus').innerHTML = 
                    `<div class="status-message status-error">Error: ${error.message}</div>`;
            }
        }
        
        function setupRealtimeSubscription() {
            if (!gameRef) return;
            
            gameChannel = supabase
                .channel(`room-${gameRef}`)
                .on('postgres_changes', 
                    { event: 'UPDATE', schema: 'public', table: 'rooms', filter: `id=eq.${gameRef}` },
                    (payload) => {
                        console.log('Room updated:', payload);
                        handleRoomUpdate(payload.new);
                    }
                )
                .subscribe();
        }
        
        function handleRoomUpdate(roomData) {
            if (!roomData.game_state) return;
            
            const gameState = roomData.game_state;
            const oldCurrentPlayer = currentPlayer;
            
            console.log('Handling room update:', gameState);
            console.log('Current player before update:', currentPlayer, 'Player number:', playerNumber);
            
            // Update local game state
            const newCurrentPlayer = gameState.currentPlayer || currentPlayer;
            const newGamePhase = gameState.gamePhase || gamePhase;
            const newCurrentTurn = gameState.currentTurn || currentTurn;
            const newTurnPhase = gameState.turnPhase || turnPhase;
            
            // Force update these values
            currentPlayer = newCurrentPlayer;
            gamePhase = newGamePhase;
            currentTurn = newCurrentTurn;
            turnPhase = newTurnPhase;
            
            console.log('Current player after update:', currentPlayer, 'Player number:', playerNumber);
            
            // Show notifications for important changes
            if (oldCurrentPlayer !== currentPlayer) {
                showNotification(`Player ${currentPlayer}'s turn!`, 'info');
            }
            
            // Reconstruct board tiles from game state
            if (gameState.boardTiles && Array.isArray(gameState.boardTiles)) {
                // Clear existing board
                boardTiles = [];
                
                // Recreate all tiles on the board
                gameState.boardTiles.forEach(boardTileData => {
                    const { col, row, tile: tileData } = boardTileData;
                    
                    // Create tile object
                    const tile = new Tile(
                        tileData.type,
                        tileData.baseInfluence,
                        tileData.char || '?',
                        tileData.color || 0x000000,
                        tileData.resourceTypes || [],
                        tileData.cost || []
                    );
                    
                    // Set tile properties
                    tile.col = col;
                    tile.row = row;
                    tile.owner = tileData.owner;
                    tile.usedThisTurn = tileData.usedThisTurn || false;
                    
                    // Place tile on board
                    placeTileDirectly(col, row, tile);
                });
                
                // Update all tile displays
                updateAllTileDisplays();
            }
            
            // Update players ready state
            if (gameState.playersReady) {
                const oldPlayersReady = { ...playersReady };
                playersReady = gameState.playersReady;
                console.log(`Player ${playerNumber}: Updated playersReady:`, playersReady);
                
                // Check for new player ready
                for (let playerNum = 1; playerNum <= 2; playerNum++) {
                    if (!oldPlayersReady[playerNum] && playersReady[playerNum]) {
                        showNotification(`Player ${playerNum} is ready!`, 'success');
                    }
                }
            }
            
            // Give capital tile to current player if it's capital placement phase
            if (gamePhase === 'capital_placement' && currentPlayer === playerNumber && playerHand.length === 0) {
                giveCapitalTile();
            }
            
            // Handle transition to normal play if both players are ready
            console.log(`Player ${playerNumber}: Checking transition - gamePhase: ${gamePhase}, playersReady:`, playersReady);
            if (gamePhase === 'capital_placement' && playersReady[1] && playersReady[2]) {
                console.log(`Player ${playerNumber}: Both players ready, transitioning to normal play via room update`);
                console.log(`Player ${playerNumber}: Current hand length before transition: ${playerHand.length}`);
                
                // Use the same transition function to ensure consistency
                transitionToNormalPlay();
            } else if (gamePhase === 'normal_play' && playersReady[1] && playersReady[2] && playerHand.length === 0) {
                // Game is in normal play but this player doesn't have any tiles yet
                console.log(`Player ${playerNumber}: Game in normal play but no tiles, drawing first turn tile`);
                drawTurnTile();
            } else {
                console.log(`Player ${playerNumber}: Not transitioning - gamePhase: ${gamePhase}, playersReady[1]: ${playersReady[1]}, playersReady[2]: ${playersReady[2]}, handLength: ${playerHand.length}`);
            }
            
            // Update UI
            updateGamePhaseDisplay();
            updateTurnPhaseDisplay();
            updateResourceDisplay();
            
            // If it's not our turn, disable interactions
            if (currentPlayer !== playerNumber) {
                // Disable tile selection and placement
                selectedTile = null;
                updateSelectedDisplay();
                showNotification(`Waiting for Player ${currentPlayer}...`, 'warning');
            } else {
                showNotification(`Your turn!`, 'success');
                
                // Draw a tile if it's this player's turn and they don't have one
                if (gamePhase === 'normal_play' && playerHand.length === 0) {
                    console.log(`Player ${playerNumber}: It's my turn but no tiles, drawing turn tile`);
                    drawTurnTile();
                }
            }
            
            console.log('Room update handled successfully');
        }
        
        async function syncGameState() {
            if (!isMultiplayer || !gameRef) return;
            
            // Debounce rapid syncs
            if (syncTimeout) {
                clearTimeout(syncTimeout);
            }
            
            syncTimeout = setTimeout(async () => {
                try {
                    const gameState = {
                        currentPlayer,
                        gamePhase,
                        turnPhase,
                        boardTiles: boardTiles.map(bt => ({
                            col: bt.col,
                            row: bt.row,
                            tile: {
                                type: bt.tile.type,
                                owner: bt.tile.owner,
                                baseInfluence: bt.tile.baseInfluence,
                                char: bt.tile.char,
                                color: bt.tile.color,
                                resourceTypes: bt.tile.resourceTypes,
                                cost: bt.tile.cost,
                                usedThisTurn: bt.tile.usedThisTurn
                            }
                        })),
                        playersReady,
                        currentTurn,
                        score: { 1: 0, 2: 0 } // Add score tracking
                    };
                    
                    console.log('Syncing game state:', gameState);
                    console.log('Syncing currentPlayer:', currentPlayer, 'gamePhase:', gamePhase);
                    
                    const { error } = await supabase
                        .from('rooms')
                        .update({ 
                            game_state: gameState,
                            current_player: currentPlayer,
                            game_phase: gamePhase
                        })
                        .eq('id', gameRef);
                    
                    if (error) throw error;
                    
                    console.log('Game state synced to Supabase successfully');
                } catch (error) {
                    console.error('Error syncing game state:', error);
                }
            }, 100); // 100ms debounce
        }
        
        function startGame() {
            initGame();
        }
        
        // Start the game when page loads
        window.addEventListener('load', async () => {
            // Test Supabase connection
            await testSupabaseConnection();
            // Don't auto-start, show room setup instead
            // initGame();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (app && app.renderer) {
                const gameBoard = document.getElementById('gameBoard');
                app.renderer.resize(gameBoard.offsetWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
